<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Research Workspace</title>
    <!-- Fix for Highlight.js module error - must be before scripts -->
    <script>window.module = {};</script>
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Add Markdown libraries -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/lib/core.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css">
    <style>
        :root {
            --primary-color: #ff0000;
            --secondary-color: #4c2885;
            --accent-color: #ff0000;
            --text-color: #e0e0e0;
            --bg-dark: #121212;
            --bg-darker: #0a0a0a;
            --bg-lighter: #1e1e1e;
            --sidebar-width: 300px;
            --header-height: 60px;
            --glow-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            display: flex;
            height: 100vh;
            background-color: var(--bg-dark);
            color: var(--text-color);
            overflow: hidden;
            position: relative;
        }

        /* 3D Background Animation Container */
        #background-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.2;
        }
        
        .sidebar {
            width: var(--sidebar-width);
            background-color: var(--bg-darker);
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            height: 100%;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
            z-index: 2;
            transition: transform 0.3s ease;
        }
        
        .sidebar-header {
            padding: 20px;
            background-color: var(--secondary-color);
            color: white;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .sidebar-header:after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: shine 3s infinite;
        }
        
        @keyframes shine {
            0% { left: -100%; }
            20% { left: 100%; }
            100% { left: 100%; }
        }

        .workspace-tools {
            padding: 15px;
            background-color: rgba(30, 30, 30, 0.5);
            border-bottom: 1px solid #333;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .timer-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .timer-display {
            font-size: 20px;
            font-weight: bold;
            font-family: monospace;
            color: var(--accent-color);
            text-shadow: var(--glow-shadow);
        }
        
        .timer-controls {
            display: flex;
            gap: 8px;
        }
        
        .timer-btn {
            background-color: var(--secondary-color);
            color: white;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .timer-btn i {
            font-size: 16px;
        }
        
        .timer-btn:hover {
            background-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: var(--glow-shadow);
        }
        
        /* Music player */
        .music-player {
            background-color: rgba(20, 20, 20, 0.3);
            border-radius: 6px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .music-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .track-info {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 14px;
        }
        
        .music-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .music-btns {
            display: flex;
            gap: 8px;
        }
        
        .music-btn {
            background-color: var(--secondary-color);
            color: white;
            width: 30px;
            height: 30px;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .music-btn:hover {
            background-color: var(--primary-color);
            transform: scale(1.1);
            box-shadow: var(--glow-shadow);
        }
        
        .volume-control {
            display: flex;
            align-items: center;
            gap: 8px;
            max-width: 100px;
            overflow: hidden;
        }
        
        .volume-icon {
            color: var(--accent-color);
            font-size: 16px;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .volume-icon:hover {
            transform: scale(1.2);
            text-shadow: var(--glow-shadow);
        }
        
        .volume-icon.muted {
            color: #ff5252;
            text-shadow: 0 0 5px rgba(255, 82, 82, 0.5);
        }
        
        .volume-slider {
            width: 100%;
            height: 4px;
            background-color: #444;
            border-radius: 2px;
            appearance: none;
            -webkit-appearance: none;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--accent-color);
            cursor: pointer;
        }
        
        .upload-area {
            padding: 20px;
            border-bottom: 1px solid #333;
            display: flex;
            flex-direction: column;
            background-color: rgba(30, 30, 30, 0.3);
            gap: 10px;
        }
        
        .file-upload-btn {
            background-color: var(--secondary-color);
            color: white;
            padding: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            z-index: 1;
        }
        
        .file-upload-btn:before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s ease;
            z-index: -1;
        }
        
        .file-upload-btn:hover {
            background-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 0 0 2px rgba(143, 67, 238, 0.3);
        }
        
        .file-upload-btn:hover:before {
            left: 100%;
        }
        
        .pdf-list {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            background-color: rgba(20, 20, 20, 0.5);
        }
        
        .pdf-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .pdf-list::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        .pdf-list::-webkit-scrollbar-thumb {
            background-color: var(--secondary-color);
            border-radius: 20px;
        }
        
        .pdf-item {
            padding: 10px;
            margin-bottom: 8px;
            background-color: var(--bg-lighter);
            border-radius: 4px;
            border-left: 3px solid var(--accent-color);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transform-style: preserve-3d;
            perspective: 500px;
        }
        
        .pdf-item:hover {
            background-color: #2a2a2a;
            transform: translateZ(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .pdf-item.active {
            border-left-color: var(--primary-color);
            background-color: rgba(76, 40, 133, 0.2);
            box-shadow: 0 0 15px rgba(143, 67, 238, 0.3);
        }
        
        .pdf-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
        }
        
        .remove-btn {
            color: #ff5252;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            padding: 2px 5px;
            border-radius: 3px;
            transition: all 0.2s ease;
        }
        
        .remove-btn:hover {
            background-color: rgba(255, 82, 82, 0.2);
            transform: scale(1.2);
        }
        
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            background-color: var(--bg-dark);
            position: relative;
            overflow: hidden;
        }
        
        .toolbar {
            padding: 15px;
            background-color: var(--bg-darker);
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1;
        }
        
        .page-display {
            color: var(--accent-color);
            font-size: 16px;
            font-weight: bold;
        }
        
        .view-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            background-color: rgba(20, 20, 20, 0.7);
            z-index: 0;
            position: relative;
        }
        
        .view-area::-webkit-scrollbar {
            width: 10px;
        }
        
        .view-area::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        .view-area::-webkit-scrollbar-thumb {
            background-color: var(--secondary-color);
            border-radius: 20px;
            border: 2px solid #1a1a1a;
        }
        
        #pdf-viewer {
            background-color: var(--bg-lighter);
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        
        .pdf-page {
            margin-bottom: 25px;
            background-color: #fff;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            transition: transform 0.3s ease;
        }
        
        .pdf-page:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
        }
        
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #888;
            text-align: center;
            padding: 30px;
        }
        
        .empty-state i {
            font-size: 72px;
            margin-bottom: 20px;
            color: var(--accent-color);
            text-shadow: 0 0 10px rgba(0, 229, 255, 0.5);
        }
        
        .empty-state p {
            font-size: 20px;
            max-width: 400px;
            line-height: 1.6;
        }

        .page-canvas {
            display: block;
            margin: 0 auto;
            border-radius: 2px;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            font-size: 18px;
            color: var (--accent-color);
            flex-direction: column;
        }
        
        .loading:after {
            content: "";
            width: 40px;
            height: 40px;
            border: 4px solid rgba(0, 229, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid var(--accent-color);
            animation: spin 1s linear infinite;
            margin-top: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Text layer styles */
        .textLayer {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 0.2;
            line-height: 1.0;
            --scale-factor: 1.5; /* Add scale factor variable to fix warnings */
        }
        
        .textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }
        
        .textLayer .highlight {
            margin: -1px;
            padding: 1px;
            background-color: rgb(180, 0, 170);
            border-radius: 4px;
        }
        
        .textLayer ::selection { 
            background: rgba(143, 67, 238, 0.4); 
        }
        
        /* Smooth scrolling */
        html {
            scroll-behavior: smooth;
        }
        
        .page-marker {
            position: relative;
        }
        
        .page-number {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            color: var(--accent-color);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            font-weight: bold;
            backdrop-filter: blur(2px);
        }
        
        /* Notes section */
        .notes-panel {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 0;
            background-color: var(--bg-darker);
            box-shadow: -2px 0 15px rgba(0,0,0,0.5);
            z-index: 3;
            transition: width 0.3s ease;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .notes-panel.open {
            width: 350px;
        }
        
        .notes-panel.open.expanded {
            width: 63vw;
        }
        
        /* Remove resize functionality */
        .notes-resize-handle {
            display: none;
        }
        
        .notes-header {
            padding: 15px;
            background-color: var(--secondary-color);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
        }
        
        /* Improved close button styling */
        .close-notes {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
            z-index: 10;
            position: relative;
        }
        
        .close-notes:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        
        .notes-actions {
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 15px;
            background-color: var(--bg-darker);
            border-top: 1px solid #333;
        }
        
        .notes-action-btn {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 10px 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 7px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .notes-action-btn i {
            font-size: 16px;
        }
        
        .notes-action-btn:hover {
            background-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), 0 0 0 2px rgba(143, 67, 238, 0.3);
        }
        
        .copy-success {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--accent-color);
            color: var(--bg-darker);
            padding: 10px 20px;
            border-radius: 4px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            z-index: 10;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .copy-success.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .notes-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 15px;
            background-color: var(--bg-lighter);
        }
        
        .notes-content::-webkit-scrollbar {
            width: 6px;
        }
        
        .notes-content::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        .notes-content::-webkit-scrollbar-thumb {
            background-color: var(--secondary-color);
            border-radius: 10px;
        }
        
        /* Live markdown editor blocks */
        .markdown-block {
            position: relative;
            margin-bottom: 15px;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .markdown-block.editing {
            background-color: rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 0 1px var(--accent-color);
        }
        
        .markdown-editor {
            width: 100%;
            min-height: 24px;
            background: transparent;
            border: none;
            color: var(--text-color);
            font-size: 14px;
            line-height: 1.6;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            resize: none;
            padding: 8px;
            overflow: hidden;
            display: none;
        }
        
        .markdown-display {
            padding: 8px;
            cursor: text;
            color: var(--text-color);
            line-height: 1.6;
            overflow-y: hidden;
        }
        
        .markdown-block.editing .markdown-editor {
            display: block;
        }
        
        .markdown-block.editing .markdown-display {
            display: none;
        }
        
        .markdown-editor:focus {
            outline: none;
        }
        
        /* Markdown styling */
        .markdown-display h1,
        .markdown-display h2,
        .markdown-display h3 {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
            color: var(--accent-color);
        }
        
        .markdown-display p {
            margin-bottom: 0.5em;
            line-height: 1.6;
        }
        
        .markdown-display ul,
        .markdown-display ol {
            margin-left: 2em;
            margin-bottom: 0.5em;
        }
        
        .markdown-display code {
            background-color: rgba(0,0,0,0.3);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 85%;
        }
        
        .markdown-display pre {
            background-color: var(--bg-darker);
            padding: 1em;
            border-radius: 5px;
            margin: 0.5em 0;
            overflow-x: auto;
            overflow-y: hidden;
        }
        
        .markdown-display blockquote {
            border-left: 3px solid var(--accent-color);
            padding-left: 1em;
            margin-left: 0;
            margin-bottom: 0.5em;
            color: #aaa;
        }
        
        .markdown-display a {
            color: var(--accent-color);
            text-decoration: none;
        }
        
        .markdown-display a:hover {
            text-decoration: underline;
        }
        
        .markdown-display img {
            max-width: 100%;
            height: auto;
        }
        
        .add-block-button {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }
        
        .add-block-btn {
            background-color: transparent;
            border: 1px dashed var(--accent-color);
            color: var(--accent-color);
            border-radius: 4px;
            padding: 5px 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 12px;
        }
        
        .add-block-btn:hover {
            background-color: rgba(0, 229, 255, 0.1);
            transform: translateY(-2px);
        }
        
        /* Remove tabs and other unused elements */
        .notes-tabs,
        .tab-pane {
            display: none;
        }
        
        /* Keep hidden input for backup */
        .markdown-input {
            display: none;
        }
        
        /* PDF Viewer Controls - Updated for better stickiness */
        .pdf-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            background: rgba(20, 20, 20, 0.8);
            padding: 10px;
            border-radius: 8px;
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            width: calc(100% - 350px);
            max-width: 500px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(76, 40, 133, 0.3);
        }
        
        /* Add margin to the first page to account for fixed controls */
        #pdf-viewer .pdf-page:first-child {
            margin-top: 60px;
        }
        
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 40vh;
            }
            
            .main-content {
                height: 60vh;
            }
            
            .notes-panel.open {
                width: 100%;
                height: 50%;
                top: 50%;
            }
        }
        
        .notes-panel .size-indicator {
            color: var(--accent-color);
            font-size: 14px;
            margin-left: 10px;
            font-weight: normal;
        }
        
        .notes-tooltip {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .notes-panel.open:hover .notes-tooltip {
            opacity: 1;
        }

        /* Add these styles for the resize buttons */
        .notes-resize-buttons {
            position: absolute;
            top: 15px;
            right: 50px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        .resize-btn {
            background-color: var(--accent-color);
            color: var(--bg-darker);
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .resize-btn:hover {
            background-color: white;
            transform: scale(1.1);
        }

        /* Replace the resize buttons styles with this single resize button style */
        .notes-resize-button {
            position: absolute;
            left: 10px; /* Position it inside the panel instead of outside */
            top: 15px; /* Align with the header */
            width: 30px;
            height: 30px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            z-index: 10;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .notes-resize-button:hover {
            background-color: var(--primary-color);
            transform: scale(1.2);
        }

        /* Remove the previous resize-buttons class */
        .notes-resize-buttons {
            display: none;
        }

        .notes-header h3 {
            margin-left: 40px; /* Make space for the resize button */
        }
    </style>
</head>
<body>
    <div id="background-animation"></div>
    
    <div class="sidebar">
        <div class="sidebar-header">
            <h2>Lab</h2>
        </div>
        
        <div class="workspace-tools">
            <div class="tools-container">
                <div class="timer-container">
                    <div class="timer-left">
                        <div class="timer-header">
                            <h4>POMODORO</h4>
                        </div>
                        <div class="timer-display" id="timer">00:00:00</div>
                    </div>
                    <div class="timer-controls">
                        <button id="start-timer" class="timer-btn">Start</button>
                        <button id="reset-timer" class="timer-btn">Reset</button>
                    </div>
                </div>
                
                <div class="music-player">
                    
                        <div class="track-info" id="track-info">Loading...</div>
                        <div class="music-btns">
                            <button class="music-btn" id="play-btn">
                                <i class="fas fa-play"></i>
                            </button>
                            <button class="music-btn" id="next-btn">
                                <i class="fas fa-forward"></i>
                            </button>
                            <div class="volume-control">
                                <i class="fas fa-volume-up volume-icon"></i>
                                <input type="range" min="0" max="100" value="70" class="volume-slider" id="volume-slider">
                            </div>
                            <audio id="audio-player"></audio>
                        </div>
       
                </div>
            </div>
            
            
        </div>
        
        <div class="upload-area">
            <input type="file" id="pdf-upload" accept=".pdf" style="display:none">
            <button class="file-upload-btn" onclick="document.getElementById('pdf-upload').click()">
                Upload Local PDF
            </button>
            
            <div class="method-separator">OR</div>
            
            <div class="url-input-container" style="display: flex; align-items: center; justify-content: center;">
                <input type="text" id="pdf-url" class="url-input" placeholder="Enter PDF URL..." style="padding: 10px; border-radius: 4px; border: 1px solid #333; margin-right: 5px;">
                <button id="load-url" class="url-load-btn" style="padding: 10px 15px; border-radius: 4px; background-color: var(--secondary-color); color: white; border: none; cursor: pointer;">Load</button>
            </div>
        </div>
        
        <div class="pdf-list" id="pdf-list">
            <!-- PDF files will be listed here -->
        </div>
    </div>
    <div class="notes-toggle" id="notes-toggle2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>
    
    <div class="main-content">
        <div class="toolbar">
            <div class="page-display" id="page-info">Page 0 of 0</div>
        </div>
        
        <div class="view-area">
            <div id="pdf-viewer">
                <div class="empty-state">
                    <i>üìö</i>
                    <p>Upload a paper or research PDF to start your study session</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="notes-panel" id="notes-panel">
        <div class="notes-resize-handle" id="notes-resize-handle"></div>
        <div class="notes-header">
            <button class="notes-resize-button" id="toggle-size-btn"><--</button>
            <h3>Research Notes</h3>
            <button class="close-notes" id="close-notes">√ó</button>
        </div>
        
        <div class="notes-content" id="notes-content">
            <!-- Live markdown blocks will be added here -->
        </div>
        
        <div class="notes-actions">
            <button class="notes-action-btn" id="copy-notes-btn" onclick="copyNotesToClipboard(); return false;">
                <i class="fas fa-clipboard"></i> Copy to Clipboard
            </button>
            <button class="notes-action-btn" id="download-notes-btn" onclick="downloadNotes(); return false;">
                <i class="fas fa-download"></i> Download Markdown
            </button>
        </div>
        
        <!-- Hidden backup textarea -->
        <textarea id="markdown-input" class="markdown-input"></textarea>
        
    </div>
    
    <div class="notes-toggle" id="notes-toggle">&nbsp;&nbsp;Take Notes&nbsp;üìù</div>
    
    <!-- Copy success notification -->
    <div class="copy-success" id="copy-success">Notes copied to clipboard!</div>
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    
    <script>
        // Ensure the PDF.js library is loaded
        if (!window.pdfjsLib) {
            alert('PDF.js library failed to load. Please check your internet connection.');
        } else {
            // Set the PDF.js worker source
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
        }
        
        // Fix for Highlight.js module error
        window.module = window.module || {};
        
        // Initialize variables
        let pdfCollection = [];
        let pdfNotes = {};
        let currentPdfIndex = -1;
        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 0;
        let scale = 1.5;
        let timerInterval = null;
        let seconds = 0;
        let minutes = 0;
        let hours = 0;
        let markdownBlocks = []; // Array to store markdown blocks
        let currentTrackIndex = 0;
        let isPlaying = false;
        
        // Ambient music playlist
        const musicPlaylist = [
            { title: "Piano 1", url: "https://assets.mixkit.co/music/22/22.mp3" },
            { title: "Piano 2", url: "https://assets.mixkit.co/music/738/738.mp3" },
            { title: "Piano 3", url: "https://assets.mixkit.co/music/614/614.mp3" },
            { title: "Piano 4", url: "https://assets.mixkit.co/music/871/871.mp3" },
            { title: "Piano 5", url: "https://assets.mixkit.co/music/587/587.mp3" },
            { title: "Piano 6", url: "https://assets.mixkit.co/music/897/897.mp3" },
            { title: "Piano 7", url: "https://assets.mixkit.co/music/684/684.mp3" },
            { title: "Piano 8", url: "https://assets.mixkit.co/music/522/522.mp3" },
            { title: "Piano 9", url: "https://assets.mixkit.co/music/682/682.mp3" },
            { title: "Piano 10", url: "https://assets.mixkit.co/music/688/688.mp3" },
            { title: "Piano 11", url: "https://assets.mixkit.co/music/31/31.mp3" },
            { title: "Piano 12", url: "https://assets.mixkit.co/music/652/652.mp3" },
            { title: "Piano 13", url: "https://assets.mixkit.co/music/531/531.mp3" },
            { title: "Piano 14", url: "https://assets.mixkit.co/music/713/713.mp3" },
            { title: "Piano 15", url: "https://assets.mixkit.co/music/79/79.mp3" }
        ];
        



        // Elements
        const pdfUpload = document.getElementById('pdf-upload');
        const pdfUrl = document.getElementById('pdf-url');
        const loadUrlBtn = document.getElementById('load-url');
        const pdfList = document.getElementById('pdf-list');
        const pdfViewer = document.getElementById('pdf-viewer');
        const pageInfo = document.getElementById('page-info');
        const notesPanel = document.getElementById('notes-panel');
        const notesToggle = document.getElementById('notes-toggle');
        const closeNotes = document.getElementById('close-notes');
        const notesContent = document.getElementById('notes-content');
        const markdownInput = document.getElementById('markdown-input');
        const notesResizeHandle = document.getElementById('notes-resize-handle');
        const timerDisplay = document.getElementById('timer');
        const startTimerBtn = document.getElementById('start-timer');
        const resetTimerBtn = document.getElementById('reset-timer');
        const audioPlayer = document.getElementById('audio-player');
        const playBtn = document.getElementById('play-btn');
        const nextBtn = document.getElementById('next-btn');
        const volumeSlider = document.getElementById('volume-slider');
        const trackInfo = document.getElementById('track-info');
        const copyNotesBtn = document.getElementById('copy-notes-btn');
        const downloadNotesBtn = document.getElementById('download-notes-btn');
        const copySuccess = document.getElementById('copy-success');
        
        // Configure marked.js
        marked.setOptions({
            highlight: function(code, lang) {
                try {
                    const language = hljs.getLanguage(lang) ? lang : 'plaintext';
                    return hljs.highlight(code, { language }).value;
                } catch(e) {
                    console.error("Highlight.js error:", e);
                    return code;
                }
            },
            langPrefix: 'hljs language-',
            gfm: true,
            breaks: true
        });
        
        // Initialize 3D background animation
        function initBackgroundAnimation() {
            // Create scene
            const scene = new THREE.Scene();
            
            // Create camera
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;
            
            // Create renderer
            const renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('background-animation').appendChild(renderer.domElement);
            
            // Create particles
            const particlesGeometry = new THREE.BufferGeometry();
            const particlesCount = 1000;
            const posArray = new Float32Array(particlesCount * 3);
            for(let i = 0; i < particlesCount * 3; i++) {
                // Random positions in 3D space
                posArray[i] = (Math.random() - 0.5) * 200;
            }
            
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            // Create material
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.8,
                color: 0xffffff,
                transparent: true
            });
            
            // Create mesh
            const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particlesMesh);
            
            // Animation function
            function animate() {
                requestAnimationFrame(animate);
                
                particlesMesh.rotation.x += 0.001;
                particlesMesh.rotation.y += 0.001;
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // Initialize timer functions
        function startTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                startTimerBtn.textContent = 'Start';
                timerInterval = null; // Make sure to set timerInterval to null
                return;
            }
            
            startTimerBtn.textContent = 'Pause';
            timerInterval = setInterval(updateTimer, 1000);
        }
        
        function resetTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null; // Make sure to set timerInterval to null
            }
            seconds = 0;
            minutes = 0;
            hours = 0;
            timerDisplay.textContent = '00:00:00';
            startTimerBtn.textContent = 'Start';
        }
        
        function updateTimer() {
            seconds++;
            if (seconds >= 60) {
                seconds = 0;
                minutes++;
                if (minutes >= 60) {
                    minutes = 0;
                    hours++;
                }
            }
            
            timerDisplay.textContent = 
                (hours ? (hours > 9 ? hours : "0" + hours) : "00") + ":" + 
                (minutes ? (minutes > 9 ? minutes : "0" + minutes) : "00") + ":" + 
                (seconds ? (seconds > 9 ? seconds : "0" + seconds) : "00");
        }
        
        // Notes panel toggle - Updated to ensure close button works
        function toggleNotesPanel() {
            console.log("Toggle notes panel called with new implementation");
            
            // Force panel to close and then reopen if needed
            if (notesPanel.classList.contains('open')) {
                // Close panel
                notesPanel.classList.remove('open');
                console.log("Panel closed");
            } else {
                // Open panel
                notesPanel.classList.add('open');
                console.log("Panel opened");
            }
        }
        
        // Notes resize functionality
        function initResizableNotes() {
            // No need for resize handlers, we're using keyboard shortcuts instead
            console.log("Notes panel size can be toggled with < and > keys");
        }
        
        // Music player functions
        function initMusicPlayer() {
            // Set initial volume (limit to 50% maximum)
            audioPlayer.volume = (volumeSlider.value / 100) * 0.1;
            
            // Load first track
            loadTrack(currentTrackIndex);
            
            // Play button event
            playBtn.addEventListener('click', togglePlay);
            
            // Next button event
            nextBtn.addEventListener('click', nextTrack);
            
            // Volume slider event
            volumeSlider.addEventListener('input', () => {
            audioPlayer.volume = (volumeSlider.value / 100) * 0.1;
            });
            
            // Handle track ending
            audioPlayer.addEventListener('ended', nextTrack);
        }
        
        function loadTrack(index) {
            const track = musicPlaylist[index];
            trackInfo.textContent = track.title;
            audioPlayer.src = track.url;
            audioPlayer.load();
            
            // Add error handling for audio loading
            audioPlayer.onerror = function() {
                console.error("Error loading audio track:", track.url);
                trackInfo.textContent = `‚ö†Ô∏è ${track.title} (Failed to load)`;
                
                // Try next track after a delay if we're playing
                if (isPlaying) {
                    setTimeout(() => {
                        nextTrack();
                    }, 2000);
                }
            };
        }
        
        function togglePlay() {
            if (isPlaying) {
                audioPlayer.pause();
                playBtn.innerHTML = '<i class="fas fa-play"></i>';
            } else {
                audioPlayer.play();
                playBtn.innerHTML = '<i class="fas fa-pause"></i>';
            }
            isPlaying = !isPlaying;
        }
        
        function nextTrack() {
            currentTrackIndex = (currentTrackIndex + 1) % musicPlaylist.length;
            loadTrack(currentTrackIndex);
            if (isPlaying) {
                audioPlayer.play();
            }
        }
        
        // Create a new markdown block
        function createMarkdownBlock(content = '', focus = false, insertAtEnd = false) {
            const block = document.createElement('div');
            block.className = 'markdown-block';
            block.id = `block-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
            
            // Create editor textarea
            const editor = document.createElement('textarea');
            editor.className = 'markdown-editor';
            editor.value = content;
            editor.placeholder = 'Write your note here...';
            
            // Create display div for rendered markdown
            const display = document.createElement('div');
            display.className = 'markdown-display';
            display.innerHTML = content ? marked.parse(content) : '<p>Click to edit...</p>';
            
            // Add elements to block
            block.appendChild(editor);
            block.appendChild(display);
            
            // Add event listeners
            display.addEventListener('click', () => {
                setEditMode(block, true);
            });
            
            editor.addEventListener('input', () => {
                autoResizeTextarea(editor);
            });
            
            editor.addEventListener('blur', () => {
                const content = editor.value.trim();
                if (content) {
                    display.innerHTML = marked.parse(content);
                    setEditMode(block, false);
                    saveNotes();
                } else if (document.querySelectorAll('.markdown-block').length > 1) {
                    // Remove empty blocks on blur, but keep at least one
                    block.remove();
                    saveNotes();
                }
            });
            
            editor.addEventListener('keydown', (e) => {
                // Enter key creates new block
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const content = editor.value;
                    const cursorPos = editor.selectionStart;
                    
                    // Text before and after cursor
                    const textBefore = content.substring(0, cursorPos);
                    const textAfter = content.substring(cursorPos);
                    
                    // Update current block with text before cursor
                    editor.value = textBefore;
                    display.innerHTML = marked.parse(textBefore);
                    
                    // Create new block with text after cursor
                    const newBlock = createMarkdownBlock(textAfter, true);
                    
                    // Insert the new block after the current block
                    block.parentNode.insertBefore(newBlock, block.nextSibling);
                    
                    // Focus the new block and place cursor at the beginning
                    const newEditor = newBlock.querySelector('.markdown-editor');
                    newEditor.focus();
                    newEditor.selectionStart = 0;
                    newEditor.selectionEnd = 0;
                    
                    saveNotes();
                }
                
                // Backspace at beginning merges with previous block
                if (e.key === 'Backspace' && editor.selectionStart === 0 && editor.selectionEnd === 0) {
                    const prevBlock = block.previousElementSibling;
                    if (prevBlock && prevBlock.classList.contains('markdown-block')) {
                        e.preventDefault();
                        
                        const prevEditor = prevBlock.querySelector('.markdown-editor');
                        if (!prevEditor) return; // Safety check
                        
                        // Make sure the previous block is in edit mode
                        setEditMode(prevBlock, true);
                        
                        const prevContent = prevEditor.value;
                        const currentContent = editor.value;
                        
                        // Store position for cursor
                        const cursorPosition = prevContent.length;
                        
                        // Remove current block first to avoid focus issues
                        const tempContent = currentContent;
                        block.remove();
                        
                        // Then set value and focus on previous editor
                        prevEditor.value = prevContent + tempContent;
                        prevEditor.focus();
                        
                        // Set cursor position to the junction point
                        prevEditor.selectionStart = prevEditor.selectionEnd = cursorPosition;
                        
                        // Update textarea height and save
                        autoResizeTextarea(prevEditor);
                        saveNotes();
                    }
                }
                
                // Arrow Up at beginning should move to previous paragraph
                if (e.key === 'ArrowUp' && editor.selectionStart === 0) {
                    const prevBlock = block.previousElementSibling;
                    if (prevBlock && prevBlock.classList.contains('markdown-block')) {
                        e.preventDefault();
                        
                        // Get the previous editor and focus it
                        const prevEditor = prevBlock.querySelector('.markdown-editor');
                        if (!prevEditor) return; // Safety check
                        
                        setEditMode(prevBlock, true);
                        prevEditor.focus();
                        
                        // Move cursor to the end of the previous editor
                        prevEditor.selectionStart = prevEditor.selectionEnd = prevEditor.value.length;
                    }
                }
                
                // Arrow Down at end should move to next paragraph
                if (e.key === 'ArrowDown' && editor.selectionStart === editor.value.length) {
                    const nextBlock = block.nextElementSibling;
                    if (nextBlock && nextBlock.classList.contains('markdown-block')) {
                        e.preventDefault();
                        
                        // Get the next editor and focus it
                        const nextEditor = nextBlock.querySelector('.markdown-editor');
                        if (!nextEditor) return; // Safety check
                        
                        setEditMode(nextBlock, true);
                        nextEditor.focus();
                        
                        // Move cursor to the beginning of the next editor
                        nextEditor.selectionStart = nextEditor.selectionEnd = 0;
                    }
                }
            });
            
            // Initial setup
            if (focus) {
                setEditMode(block, true);
            }
            
            // Determine where to add the block
            if (insertAtEnd) {
                // Insert before the "Add note block" button if it exists
                const addButton = document.querySelector('.add-block-button');
                if (addButton) {
                    notesContent.insertBefore(block, addButton);
                } else {
                    notesContent.appendChild(block);
                }
            }
            
            return block;
        }
        
        // Set edit mode for a block
        function setEditMode(block, isEditing) {
            if (isEditing) {
                // Set all other blocks to non-editing mode
                document.querySelectorAll('.markdown-block.editing').forEach(b => {
                    if (b !== block) b.classList.remove('editing');
                });
                
                block.classList.add('editing');
                const editor = block.querySelector('.markdown-editor');
                editor.focus();
                autoResizeTextarea(editor);
            } else {
                block.classList.remove('editing');
            }
        }
        
        // Auto-resize textarea
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = (textarea.scrollHeight) + 'px';
        }
        
        // Add a new empty block button
        function addNewBlockButton() {
            // Remove existing button if any
            const existingButton = document.querySelector('.add-block-button');
            if (existingButton) {
                existingButton.remove();
            }
            
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'add-block-button';
            
            const button = document.createElement('button');
            button.className = 'add-block-btn';
            button.textContent = '+ Add note block';
            button.addEventListener('click', () => {
                const newBlock = createMarkdownBlock('', true, true);
                // The block is already added in createMarkdownBlock with insertAtEnd=true
            });
            
            buttonContainer.appendChild(button);
            notesContent.appendChild(buttonContainer);
        }
        
        // Initialize notes editor
        function initNotesEditor() {
            // Clear existing content
            notesContent.innerHTML = '';
            
            // Add initial block if notes are empty
            if (!markdownInput.value.trim()) {
                const block = createMarkdownBlock('');
                notesContent.appendChild(block);
            } else {
                // Split existing notes into blocks
                const paragraphs = markdownInput.value.split('\n\n').filter(p => p.trim());
                
                paragraphs.forEach(p => {
                    const block = createMarkdownBlock(p);
                    notesContent.appendChild(block);
                });
            }
            
            // Add button to create new blocks
            addNewBlockButton();
        }
        
        // Save notes from blocks to hidden input
        function saveNotes() {
            const blocks = document.querySelectorAll('.markdown-block');
            const contents = [];
            
            blocks.forEach(block => {
                const editor = block.querySelector('.markdown-editor');
                const content = editor.value.trim();
                if (content) contents.push(content);
            });
                
            markdownInput.value = contents.join('\n\n');
            
            // Save to localStorage if current PDF is selected
            if (currentPdfIndex >= 0 && pdfCollection[currentPdfIndex]) {
                const pdfId = pdfCollection[currentPdfIndex].id;
                pdfNotes[pdfId] = markdownInput.value;
                localStorage.setItem('pdfNotes', JSON.stringify(pdfNotes));
            }
        }
        
        // Load notes for current PDF
        function loadNotes() {
            if (currentPdfIndex >= 0 && pdfCollection[currentPdfIndex]) {
                const pdfId = pdfCollection[currentPdfIndex].id;
                markdownInput.value = pdfNotes[pdfId] || '';
            } else {
                markdownInput.value = '';
            }
            
            initNotesEditor();
        }
        
        // Copy markdown notes to clipboard
        function copyNotesToClipboard() {
            try {
                console.log("Starting copy to clipboard");
                // Ensure notes are saved first
                saveNotes();
                
                // Get combined markdown content
                const markdown = markdownInput.value;
                
                if (!markdown.trim()) {
                    alert('No notes to copy.');
                    return;
                }
                
                // Create a temporary element
                const textarea = document.createElement('textarea');
                textarea.value = markdown;
                textarea.setAttribute('readonly', '');
                textarea.style.position = 'absolute';
                textarea.style.left = '-9999px';
                document.body.appendChild(textarea);
                
                // Select the text and copy
                textarea.select();
                document.execCommand('copy');
                
                // Remove the temporary element
                document.body.removeChild(textarea);
                
                // Show success notification
                copySuccess.classList.add('show');
                
                // Hide after 2 seconds
                setTimeout(() => {
                    copySuccess.classList.remove('show');
                }, 2000);
                
                console.log("Copy completed successfully");
            } catch (error) {
                console.error('Copy error:', error);
                alert('Failed to copy notes. Please try again.');
            }
        }
        
        // Download markdown notes as file
        function downloadNotes() {
            try {
                console.log("Starting download");
                // Ensure notes are saved first
                saveNotes();
                
                // Get combined markdown content
                const markdown = markdownInput.value;
                
                if (!markdown.trim()) {
                    alert('No notes to download.');
                    return;
                }
                
                // Create filename
                let filename = 'research-notes.md';
                
                // If associated with a PDF, use PDF name for filename
                if (currentPdfIndex >= 0 && pdfCollection[currentPdfIndex]) {
                    const pdfName = pdfCollection[currentPdfIndex].name;
                    // Remove .pdf extension if present and add .md
                    filename = pdfName.replace(/\.pdf$/i, '') + '-notes.md';
                }
                
                // Create a Blob and download link
                const blob = new Blob([markdown], { type: 'text/markdown' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                
                // Append to the document, click and cleanup
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                
                console.log("Download completed successfully");
            } catch (error) {
                console.error('Download error:', error);
                alert('Failed to download notes: ' + error.message);
            }
        }
        
        // Load PDFs from localStorage on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize 3D background
            initBackgroundAnimation();
            
            // Initialize resizable notes panel
            initResizableNotes();
            
            // Initialize music player
            initMusicPlayer();
            
            // Initialize timer buttons
            initializeTimerButtons();
            
            // Remove the controls initialization from here since we'll do it after PDF loading
            // Instead, make sure empty state doesn't have controls
            const emptyPdfViewer = document.getElementById('pdf-viewer');
            emptyPdfViewer.innerHTML = `
                <div class="empty-state">
                    <i>üìö</i>
                    <p>Upload a paper or research PDF to start your study session</p>
                </div>
            `;
            
            // Load PDF collection
            const storedPdfs = localStorage.getItem('pdfCollection');
            if (storedPdfs) {
                try {
                    pdfCollection = JSON.parse(storedPdfs);
                    renderPdfList();
                } catch (error) {
                    console.error('Error loading stored PDFs:', error);
                    localStorage.removeItem('pdfCollection');
                    pdfCollection = [];
                }
            }
            
            // Load saved notes
            const storedNotes = localStorage.getItem('pdfNotes');
            if (storedNotes) {
                try {
                    pdfNotes = JSON.parse(storedNotes);
                } catch (error) {
                    console.error('Error loading stored notes:', error);
                    localStorage.removeItem('pdfNotes');
                    pdfNotes = {};
                }
            }
            
            // Setup event listeners for notes - Improved close button functionality
            notesToggle.addEventListener('click', function(e) {
                e.preventDefault();
                console.log("Notes toggle clicked");
                toggleNotesPanel();
                
                // Initialize size indicator when panel is opened
                setTimeout(() => {
                    if (notesPanel.classList.contains('open')) {
                        updateSizeIndicator(notesPanel.classList.contains('expanded'));
                    }
                }, 300);
            });
            
            // Force close button to use completely separate logic
            if (closeNotes) {
                // Remove any existing event listeners (just in case)
                closeNotes.removeEventListener('click', toggleNotesPanel);
                console.log("Adding click listener to close button");
                // Add a direct close function instead of toggle
                closeNotes.addEventListener('click', function(e) {
                    console.log("Close button clicked - direct close");
                    e.preventDefault();
                    e.stopPropagation();
                    // Force panel to close by directly removing the class
                    notesPanel.classList.remove('open');
                });
                // Add onclick handler as a backup
                closeNotes.onclick = function(e) {
                    console.log("Close button onclick triggered");
                    e.stopPropagation();
                    notesPanel.classList.remove('open');
                };
                // Remove the onclick attribute that might be conflicting
                closeNotes.removeAttribute('onclick');
            }
            
            // Add escape key to close notes panel
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && notesPanel.classList.contains('open')) {
                    toggleNotesPanel();
                }
            });
            
            // Initialize notes editor
            initNotesEditor();
            
            // URL loading
            loadUrlBtn.addEventListener('click', () => {
                const url = pdfUrl.value.trim();
                if (url) {
                    console.log("Loading PDF from URL:", url);
                    loadPdfFromUrl(url);
                } else {
                    alert('Please enter a valid URL');
                }
            });
            
            // Allow Enter key in URL input
            pdfUrl.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    loadUrlBtn.click();
                }
            });
            
            // Other event listeners
            startTimerBtn.addEventListener('click', startTimer);
            resetTimerBtn.addEventListener('click', resetTimer);
            copyNotesBtn.addEventListener('click', function(e) {
                e.preventDefault();
                console.log('Copy button clicked');
                copyNotesToClipboard();
            });
            downloadNotesBtn.addEventListener('click', function(e) {
                e.preventDefault();
                console.log('Download button clicked');
                downloadNotes();
            });

        });
        
        // Handle PDF upload
        pdfUpload.addEventListener('change', async (e) => {
            if (!e.target.files.length) return;
            
            const file = e.target.files[0];
            if (!file.type.includes('pdf')) {
                alert('Please select a PDF file.');
                return;
            }
            
            if (file.size > 10 * 1024 * 1024) { // Over 10MB
                alert('Warning: Large PDFs (>10MB) may not save properly due to browser storage limitations.');
            }
            
            pdfViewer.innerHTML = '<div class="loading">Loading your research paper...</div>';
            
            try {
                // Read the PDF file
                const reader = new FileReader();
                reader.onload = async function(event) {
                    try {
                        const arrayBuffer = event.target.result;
                        
                        // Convert ArrayBuffer to Base64 for storage
                        const base64Data = arrayBufferToBase64(arrayBuffer);
                        
                        // Store PDF in collection
                        const pdfItem = {
                            id: Date.now(),
                            name: file.name,
                            data: base64Data
                        };
                        
                        pdfCollection.push(pdfItem);
                        
                        try {
                            savePdfCollection();
                            renderPdfList();
                            
                            // Load the newly added PDF
                            currentPdfIndex = pdfCollection.length - 1;
                            loadPdf(arrayBuffer);
                            loadNotes();
                        } catch (storageError) {
                            // If storage fails but PDF is loaded, let user continue working with current PDF
                            console.error("Failed to save PDF to storage but will display it:", storageError);
                            // Still try to render current PDF
                            currentPdfIndex = pdfCollection.length - 1;
                            loadPdf(arrayBuffer);
                        }
                    } catch (processError) {
                        console.error('Error processing PDF:', processError);
                        pdfViewer.innerHTML = `<div class="error">Error processing PDF: ${processError.message}</div>`;
                    }
                };
                
                reader.onerror = function() {
                    console.error('Error reading file');
                    pdfViewer.innerHTML = `<div class="error">Error reading PDF file</div>`;
                };
                
                reader.readAsArrayBuffer(file);
            } catch (error) {
                console.error('PDF upload error:', error);
                pdfViewer.innerHTML = `<div class="error">Error uploading PDF: ${error.message}</div>`;
            }
        });
        
        // Convert ArrayBuffer to Base64 string
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }
        
        // Convert Base64 string back to ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Save PDF collection to localStorage
        function savePdfCollection() {
            try {
                // First attempt to save the collection with full data
                try {
                    localStorage.setItem('pdfCollection', JSON.stringify(pdfCollection));
                    return; // Exit if successful
                } catch (e) {
                    console.warn("Storage quota exceeded. Attempting to reduce data size...");
                }
                
                // If we reach here, we need to reduce the data size
                // 1. Remove all PDFs older than 7 days and try again
                const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
                const reducedCollection = pdfCollection.filter(pdf => pdf.id > oneWeekAgo);
                
                if (reducedCollection.length < pdfCollection.length) {
                    pdfCollection = reducedCollection;
                    try {
                        localStorage.setItem('pdfCollection', JSON.stringify(pdfCollection));
                        alert("Some older PDFs have been removed to save space. Your recent PDFs are still available.");
                        return;
                    } catch (e) {
                        console.warn("Still exceeding quota after removing old PDFs.");
                    }
                }
                
                // 2. Last resort: Keep only the current PDF
                if (currentPdfIndex >= 0) {
                    const currentPdf = pdfCollection[currentPdfIndex];
                    pdfCollection = [currentPdf];
                    try {
                        localStorage.setItem('pdfCollection', JSON.stringify(pdfCollection));
                        alert("Storage limit reached. Only your current PDF has been saved.");
                        return;
                    } catch (e) {
                        console.error("Failed to save even a single PDF.");
                    }
                }
                
                // 3. If all else fails, clear the collection
                pdfCollection = [];
                localStorage.setItem('pdfCollection', JSON.stringify(pdfCollection));
                alert("Storage limit reached. PDF collection has been cleared.");
            } catch (error) {
                console.error('Error saving PDF collection:', error);
                alert('Failed to save PDFs due to storage limitations.');
            }
        }

        // Render the PDF list in sidebar
        function renderPdfList() {
            pdfList.innerHTML = '';
            
            if (pdfCollection.length === 0) {
                pdfList.innerHTML = '<div style="padding: 15px; text-align: center; color: #888;">No research papers added yet</div>';
                return;
            }
            
            pdfCollection.forEach((pdf, index) => {
                const pdfItem = document.createElement('div');
                pdfItem.className = `pdf-item ${index === currentPdfIndex ? 'active' : ''}`;
                
                // Add URL indicator if this PDF was loaded from a URL
                const sourceIcon = pdf.url ? 'üîó ' : 'üìÑ ';
                
                pdfItem.innerHTML = `
                    <div class="pdf-title">${sourceIcon}${pdf.name}</div>
                    <button class="remove-btn" data-index="${index}">√ó</button>
                `;
                
                pdfItem.addEventListener('click', (e) => {
                    if (e.target.className === 'remove-btn' || e.target.closest('.remove-btn')) {
                        return; // Let the remove button handler handle the click
                    }
                    
                    // Save current notes before switching
                    saveNotes();
                    
                    currentPdfIndex = index;
                    // Convert the stored Base64 data back to ArrayBuffer before loading
                    const arrayBuffer = base64ToArrayBuffer(pdf.data);
                    loadPdf(arrayBuffer);
                    loadNotes();
                    updateActiveItem();
                });
                
                pdfList.appendChild(pdfItem);
            });
            
            // Add event listeners to remove buttons
            document.querySelectorAll('.remove-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const index = parseInt(e.target.dataset.index);
                    removePdf(index);
                });
            });
        }

        // Remove PDF from collection
        function removePdf(index) {
            if (confirm('Are you sure you want to remove this research paper?')) {
                // Remove notes for this PDF
                if (pdfCollection[index]) {
                    const pdfId = pdfCollection[index].id;
                    if (pdfNotes[pdfId]) {
                        delete pdfNotes[pdfId];
                        localStorage.setItem('pdfNotes', JSON.stringify(pdfNotes));
                    }
                }
                
                pdfCollection.splice(index, 1);
                savePdfCollection();
                
                // Reset view if current PDF is removed
                if (currentPdfIndex === index) {
                    currentPdfIndex = -1;
                    pdfViewer.innerHTML = `
                        <div class="empty-state">
                            <i>üìö</i>
                            <p>Upload a paper or research PDF to start your study session</p>
                        </div>
                    `;
                    markdownInput.value = '';
                    initNotesEditor();
                    updatePageControls();
                } else if (currentPdfIndex > index) {
                    currentPdfIndex--; // Adjust index if a PDF before the current one is removed
                }
                
                renderPdfList();
            }
        }

        // Update active item in the list
        function updateActiveItem() {
            document.querySelectorAll('.pdf-item').forEach((item, index) => {
                if (index === currentPdfIndex) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }

        // Load PDF document
        async function loadPdf(pdfData) {
            try {
                pdfViewer.innerHTML = '<div class="loading">Loading PDF...</div>';
                
                pdfDoc = await pdfjsLib.getDocument({ data: pdfData }).promise;
                totalPages = pdfDoc.numPages;
                currentPage = 1;
                updatePageControls();
                
                // Render all pages at once
                await renderAllPages();
            } catch (error) {
                console.error('Error loading PDF:', error);
                pdfViewer.innerHTML = `<div class="error">Error loading PDF: ${error.message}</div>`;
            }
        }

        // Render all PDF pages
        async function renderAllPages() {
            pdfViewer.innerHTML = '<div class="loading">Rendering all pages...</div>';
            
            try {
                const fragment = document.createDocumentFragment();
                
                // Create PDF controls first
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'pdf-controls';
                controlsDiv.innerHTML = `
                    <button class="pdf-control-btn" id="zoom-out"><i class="fas fa-search-minus"></i></button>
                    <div class="zoom-level" id="zoom-level">${Math.round(scale * 100)}%</div>
                    <button class="pdf-control-btn" id="zoom-in"><i class="fas fa-search-plus"></i></button>
                    <button class="pdf-control-btn" id="prev-page"><i class="fas fa-arrow-left"></i></button>
                    <button class="pdf-control-btn" id="next-page"><i class="fas fa-arrow-right"></i></button>
                `;
                
                // Add controls to fragment first
                fragment.appendChild(controlsDiv);
                
                // Render each page
                for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                    const pageDiv = document.createElement('div');
                    pageDiv.className = 'pdf-page';
                    pageDiv.id = `page-${pageNum}`;
                    pageDiv.dataset.pageNumber = pageNum;
                    
                    const pageMarker = document.createElement('div');
                    pageMarker.className = 'page-marker';
                    pageMarker.id = `marker-${pageNum}`;
                    
                    // Add page number indicator
                    const pageNumberDiv = document.createElement('div');
                    pageNumberDiv.className = 'page-number';
                    pageNumberDiv.textContent = pageNum;
                    
                    pageDiv.appendChild(pageMarker);
                    pageDiv.appendChild(pageNumberDiv);
                    fragment.appendChild(pageDiv);
                    
                    // We'll render the content of the page asynchronously
                    renderPageContent(pageNum, pageDiv);
                }
                
                pdfViewer.innerHTML = '';
                pdfViewer.appendChild(fragment);
                
                // Re-initialize PDF controls after they've been added to the DOM
                initPdfControls();
                
                // Scroll to the first page
                scrollToPage(currentPage);
                
            } catch (error) {
                console.error('Error rendering pages:', error);
                pdfViewer.innerHTML = `<div class="error">Error rendering pages: ${error.message}</div>`;
            }
        }

        // Render individual page content
        async function renderPageContent(pageNum, pageDiv) {
            try {
                const page = await pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale });
                
                // Create canvas for the page
                const canvas = document.createElement('canvas');
                canvas.className = 'page-canvas';
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                
                // Render PDF page to canvas
                const renderContext = {
                    canvasContext: context,
                    viewport
                };
                
                // Insert canvas at the beginning of the page div
                pageDiv.insertBefore(canvas, pageDiv.firstChild);
                
                await page.render(renderContext).promise;
                
                // Create text layer for selection with updated API
                const textLayer = document.createElement('div');
                textLayer.className = 'textLayer';
                textLayer.style.setProperty('--scale-factor', scale.toString());
                pageDiv.appendChild(textLayer);
                
                // Get text content using newer API
                const textContent = await page.getTextContent();
                
                // Use updated renderTextLayer with textContentSource
                pdfjsLib.renderTextLayer({
                    textContentSource: textContent,
                    container: textLayer,
                    viewport: viewport,
                    textDivs: []
                });
            } catch (error) {
                console.error(`Error rendering page ${pageNum}:`, error);
                pageDiv.innerHTML += `<div class="error">Error rendering page ${pageNum}: ${error.message}</div>`;
            }
        }

        // Scroll to specific page
        function scrollToPage(pageNum) {
            const pageElement = document.getElementById(`page-${pageNum}`);
            if (pageElement) {
                pageElement.scrollIntoView({ behavior: 'smooth' });
                
                // Update current page indicator after scrolling
                setTimeout(() => {
                    currentPage = pageNum;
                    updatePageControls();
                    updateActiveItem();
                }, 500);
            }
        }

        // Simplified page controls update
        function updatePageControls() {
            if (!pdfDoc) {
                pageInfo.textContent = 'No PDF loaded';
                return;
            }
            
            pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
        }

        // Monitor scrolling to update current page indicator
        document.querySelector('.view-area').addEventListener('scroll', function() {
            if (!pdfDoc) return;
            
            // Use Intersection Observer or calculate which page is most visible
            const pages = document.querySelectorAll('.pdf-page');
            let closestPage = 1;
            let closestDistance = Infinity;
            
            const viewAreaRect = this.getBoundingClientRect();
            const viewAreaCenter = viewAreaRect.top + (viewAreaRect.height / 2);
            
            pages.forEach(page => {
                const rect = page.getBoundingClientRect();
                const distance = Math.abs(rect.top + (rect.height / 2) - viewAreaCenter);
                
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestPage = parseInt(page.dataset.pageNumber);
                }
            });
            
            if (closestPage !== currentPage) {
                currentPage = closestPage;
                updatePageControls();
                updateActiveItem();
            }
        }, { passive: true });

        // Render single page function is no longer used but kept for reference
        async function renderPage(pageNum) {
            // This function is replaced by renderAllPages and renderPageContent
            scrollToPage(pageNum);
        }

        // Fix for PDF URL loading
        function loadPdfFromUrl(url) {
            if (!url.startsWith('http')) {
                url = 'https://' + url;
            }
            
            pdfViewer.innerHTML = '<div class="loading">Loading PDF from URL...</div>';
            
            // Use fetch to get the PDF data
            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.arrayBuffer();
                })
                .then(arrayBuffer => {
                    // Convert ArrayBuffer to Base64 for storage
                    const base64Data = arrayBufferToBase64(arrayBuffer);
                    
                    // Extract filename from URL or use generic name
                    let filename = url.split('/').pop();
                    if (!filename || filename.length > 50) {
                        filename = 'Document-' + new Date().toISOString().slice(0, 10);
                    }
                    
                    // Store PDF in collection
                    const pdfItem = {
                        id: Date.now(),
                        name: filename,
                        data: base64Data,
                        url: url // Save the original URL
                    };
                    
                    pdfCollection.push(pdfItem);
                    savePdfCollection();
                    renderPdfList();
                    
                    // Load the newly added PDF
                    currentPdfIndex = pdfCollection.length - 1;
                    loadPdf(arrayBuffer);
                    loadNotes();
                })
                .catch(error => {
                    console.error('Error loading PDF from URL:', error);
                    pdfViewer.innerHTML = `
                        <div class="error">
                            <p>Error loading PDF from URL: ${error.message}</p>
                            <p>Please check the URL and try again.</p>
                        </div>
                    `;
                });
        }

        // Improved button handlers - use direct onclick attribute + these function wrappers
        function ensureCopyButtonsWork() {
            // Direct onclick handlers as backup for the event listeners
            document.getElementById('copy-notes-btn').onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Copy button clicked via onclick');
                copyNotesToClipboard();
                return false;
            };
            
            document.getElementById('download-notes-btn').onclick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Download button clicked via onclick');
                downloadNotes();
                return false;
            };
        }
        
        // Set up event listeners with clear logging - run right away
        window.addEventListener('DOMContentLoaded', () => {
            // Additional direct event listeners for buttons with capture phase
            copyNotesBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Copy button clicked via addEventListener');
                copyNotesToClipboard();
            }, true); // Use capture phase
            
            downloadNotesBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Download button clicked via addEventListener');
                downloadNotes();
            }, true); // Use capture phase
            
            // Extra safety to ensure buttons work
            setTimeout(ensureCopyButtonsWork, 1000);
        });

        // Elements for PDF controls
        let zoomOutBtn, zoomInBtn, zoomLevelDisplay, prevPageBtn, nextPageBtn;
        
        // Initialize PDF viewer and controls - Modified for better initialization
        function initPdfControls() {
            // Initialize PDF control elements
            zoomOutBtn = document.getElementById('zoom-out');
            zoomInBtn = document.getElementById('zoom-in');
            zoomLevelDisplay = document.getElementById('zoom-level');
            prevPageBtn = document.getElementById('prev-page');
            nextPageBtn = document.getElementById('next-page');
            
            if (!zoomOutBtn || !zoomInBtn || !zoomLevelDisplay || !prevPageBtn || !nextPageBtn) {
                console.warn("PDF controls not found in the DOM");
                return;
            }
            
            // Set zoom buttons functionality
            zoomOutBtn.addEventListener('click', () => {
                if (scale > 0.5) {
                    scale -= 0.25;
                    updateZoomDisplay();
                    rerenderCurrentPdf();
                }
            });
            
            zoomInBtn.addEventListener('click', () => {
                if (scale < 3) {
                    scale += 0.25;
                    updateZoomDisplay();
                    rerenderCurrentPdf();
                }
            });
            
            // Set page navigation buttons
            prevPageBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    scrollToPage(currentPage - 1);
                }
            });
            
            nextPageBtn.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    scrollToPage(currentPage + 1);
                }
            });
            
            // Update zoom display
            updateZoomDisplay();
        }
        
        // Update zoom level display
        function updateZoomDisplay() {
            if (zoomLevelDisplay) {
                zoomLevelDisplay.textContent = `${Math.round(scale * 100)}%`;
            }
        }
        
        // Rerender the current PDF with new scale
        function rerenderCurrentPdf() {
            if (currentPdfIndex >= 0 && pdfCollection[currentPdfIndex]) {
                try {
                    const arrayBuffer = base64ToArrayBuffer(pdfCollection[currentPdfIndex].data);
                    loadPdf(arrayBuffer);
                } catch (error) {
                    console.error("Error re-rendering PDF with new scale:", error);
                    alert("Error applying zoom. The PDF might be too large for your browser's memory.");
                }
            }
        }
        
        // Load PDFs from localStorage on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize PDF controls
            initPdfControls();
        });
        
        // Keyboard shortcuts for PDF navigation and zoom
        document.addEventListener('keydown', (e) => {
            // Only process when a PDF is loaded
            if (pdfDoc) {
                // Page navigation
                if (e.key === 'ArrowRight' && !e.ctrlKey) {
                    if (currentPage < totalPages) {
                        scrollToPage(currentPage + 1);
                    }
                } else if (e.key === 'ArrowLeft' && !e.ctrlKey) {
                    if (currentPage > 1) {
                        scrollToPage(currentPage - 1);
                    }
                }
                
                // Zoom controls
                if (e.ctrlKey && e.key === '=') {
                    e.preventDefault();
                    if (scale < 3) {
                        scale += 0.25;
                        updateZoomDisplay();
                        rerenderCurrentPdf();
                    }
                } else if (e.ctrlKey && e.key === '-') {
                    e.preventDefault();
                    if (scale > 0.5) {
                        scale -= 0.25;
                        updateZoomDisplay();
                        rerenderCurrentPdf();
                    }
                }
                
                // Notes panel size controls
                if (e.key === '<' && notesPanel.classList.contains('open')) {
                    notesPanel.classList.remove('expanded');
                    updateSizeIndicator(false);
                    console.log("Notes panel collapsed to normal size");
                } else if (e.key === '>' && notesPanel.classList.contains('open')) {
                    notesPanel.classList.add('expanded');
                    updateSizeIndicator(true);
                    console.log("Notes panel expanded to larger size");
                }
            }
        });
        
        // Update the size indicator when panel size changes
        function updateSizeIndicator(isExpanded) {
            const sizeIndicator = document.getElementById('size-indicator');
            if (sizeIndicator) {
                if (isExpanded) {
                    sizeIndicator.textContent = "[Expanded - Press < to collapse]";
                } else {
                    sizeIndicator.textContent = "[Normal size - Press > to expand]";
                }
            }
        }

        // Add this JavaScript code to handle the resize buttons
        const toggleSizeBtn = document.getElementById('toggle-size-btn');
    
        if (toggleSizeBtn) {
            toggleSizeBtn.addEventListener('click', function() {
                // Toggle expanded state
                if (notesPanel.classList.contains('expanded')) {
                    notesPanel.classList.remove('expanded');
                    toggleSizeBtn.innerHTML = '<--'; // Universal resize icon
                } else {
                    notesPanel.classList.add('expanded');
                    toggleSizeBtn.innerHTML = '-->'; // Keep the same icon for consistency
                }
            });
        }

        // Add this function to ensure timer buttons work properly
        function initializeTimerButtons() {
            const startTimerBtn = document.getElementById('start-timer');
            const resetTimerBtn = document.getElementById('reset-timer');
            
            // Remove old event listeners if any
            startTimerBtn.removeEventListener('click', startTimer);
            resetTimerBtn.removeEventListener('click', resetTimer);
            
            // Add fresh event listeners
            startTimerBtn.addEventListener('click', startTimer);
            resetTimerBtn.addEventListener('click', resetTimer);
        }
    </script>
</body>
</html>


